package handler

import (
	"context"

	"github.com/jgsheppa/llm-as-judge-mcp-server/internal/client"
	"github.com/mark3labs/mcp-go/mcp"
)

// JudgeHandler handles LLM response judgment requests
type JudgeHandler struct {
	client client.LLMClient
}

// NewJudgeHandler creates a new judge handler with the provided clients
func NewJudgeHandler(client client.LLMClient) *JudgeHandler {
	return &JudgeHandler{
		client: client,
	}
}

// NewTool creates the MCP tool definition for judge_response
func NewTool() mcp.Tool {
	return mcp.NewTool("judge_response",
		mcp.WithDescription("Judge an LLM's response"),
		mcp.WithString("question",
			mcp.Required(),
			mcp.Description("the question posed to an LLM"),
		),
		mcp.WithString("response",
			mcp.Required(),
			mcp.Description("the response generated by an LLM based on the question"),
		),
		mcp.WithString("evaluation_focus",
			mcp.Description("optional - specific areas to emphasize"),
		),
	)
}

// Handle processes the judge_response tool request
func (h *JudgeHandler) Handle(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	question, err := request.RequireString("question")
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	response, err := request.RequireString("response")
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	evaluationFocus, _ := request.RequireString("evaluation_focus")

	llmClient := h.client

	// Call the client to judge the response
	result, err := llmClient.Judge(ctx, question, response, evaluationFocus)
	if err != nil {
		return mcp.NewToolResultError(err.Error()), nil
	}

	return mcp.NewToolResultText(result), nil
}
